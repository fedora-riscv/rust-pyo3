From 41a09c59c159c41cc93debfb77a1b0aea7aff328 Mon Sep 17 00:00:00 2001
From: Fabio Valentini <decathorpe@gmail.com>
Date: Sun, 14 Feb 2021 16:07:24 +0100
Subject: [PATCH] add missing type parameters that cannot be inferred

---
 src/types/boolobject.rs |  4 ++--
 src/types/datetime.rs   |  4 ++--
 src/types/iterator.rs   |  8 ++++----
 src/types/set.rs        |  4 ++--
 src/types/tuple.rs      | 14 +++++++-------
 5 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/src/types/boolobject.rs b/src/types/boolobject.rs
index 1853631bc..2993384be 100644
--- a/src/types/boolobject.rs
+++ b/src/types/boolobject.rs
@@ -69,7 +69,7 @@ mod test {
         let py = gil.python();
         assert!(PyBool::new(py, true).is_true());
         let t: &PyAny = PyBool::new(py, true).into();
-        assert_eq!(true, t.extract().unwrap());
+        assert_eq!(true, t.extract::<bool>().unwrap());
         assert_eq!(true.to_object(py), PyBool::new(py, true).into());
     }
 
@@ -79,7 +79,7 @@ mod test {
         let py = gil.python();
         assert!(!PyBool::new(py, false).is_true());
         let t: &PyAny = PyBool::new(py, false).into();
-        assert_eq!(false, t.extract().unwrap());
+        assert_eq!(false, t.extract::<bool>().unwrap());
         assert_eq!(false.to_object(py), PyBool::new(py, false).into());
     }
 }
diff --git a/src/types/datetime.rs b/src/types/datetime.rs
index aef3dc36a..81b6b839a 100644
--- a/src/types/datetime.rs
+++ b/src/types/datetime.rs
@@ -415,8 +415,8 @@ fn opt_to_pyobj(py: Python, opt: Option<&PyObject>) -> *mut ffi::PyObject {
 mod tests {
     #[test]
     fn test_new_with_fold() {
-        pyo3::Python::with_gil(|py| {
-            use pyo3::types::{PyDateTime, PyTimeAccess};
+        crate::Python::with_gil(|py| {
+            use crate::types::{PyDateTime, PyTimeAccess};
 
             let a = PyDateTime::new_with_fold(py, 2021, 1, 23, 20, 32, 40, 341516, None, false);
             let b = PyDateTime::new_with_fold(py, 2021, 1, 23, 20, 32, 40, 341516, None, true);
diff --git a/src/types/iterator.rs b/src/types/iterator.rs
index e9c0a674e..de5f7c367 100644
--- a/src/types/iterator.rs
+++ b/src/types/iterator.rs
@@ -110,8 +110,8 @@ mod tests {
         let obj = vec![10, 20].to_object(py);
         let inst = obj.as_ref(py);
         let mut it = inst.iter().unwrap();
-        assert_eq!(10, it.next().unwrap().unwrap().extract().unwrap());
-        assert_eq!(20, it.next().unwrap().unwrap().extract().unwrap());
+        assert_eq!(10, it.next().unwrap().unwrap().extract::<i32>().unwrap());
+        assert_eq!(20, it.next().unwrap().unwrap().extract::<i32>().unwrap());
         assert!(it.next().is_none());
     }
 
@@ -132,7 +132,7 @@ mod tests {
             let inst = obj.as_ref(py);
             let mut it = inst.iter().unwrap();
 
-            assert_eq!(10, it.next().unwrap().unwrap().extract().unwrap());
+            assert_eq!(10, it.next().unwrap().unwrap().extract::<i32>().unwrap());
         }
         assert_eq!(count, obj.get_refcnt(Python::acquire_gil().python()));
     }
@@ -160,7 +160,7 @@ mod tests {
             let inst = obj.as_ref(py);
             let mut it = inst.iter().unwrap();
 
-            assert_eq!(10, it.next().unwrap().unwrap().extract().unwrap());
+            assert_eq!(10, it.next().unwrap().unwrap().extract::<i32>().unwrap());
             assert!(it.next().unwrap().unwrap().is_none());
         }
         assert_eq!(count, none.get_refcnt(py));
diff --git a/src/types/set.rs b/src/types/set.rs
index 3989edfb5..d702b4b27 100644
--- a/src/types/set.rs
+++ b/src/types/set.rs
@@ -495,12 +495,12 @@ mod test {
 
         // iter method
         for el in set.iter() {
-            assert_eq!(1i32, el.extract().unwrap());
+            assert_eq!(1i32, el.extract::<i32>().unwrap());
         }
 
         // intoiterator iteration
         for el in set {
-            assert_eq!(1i32, el.extract().unwrap());
+            assert_eq!(1i32, el.extract::<i32>().unwrap());
         }
     }
 
diff --git a/src/types/tuple.rs b/src/types/tuple.rs
index 9dbe93951..d31802322 100644
--- a/src/types/tuple.rs
+++ b/src/types/tuple.rs
@@ -281,9 +281,9 @@ mod test {
         let tuple = <PyTuple as PyTryFrom>::try_from(ob.as_ref(py)).unwrap();
         assert_eq!(3, tuple.len());
         let mut iter = tuple.iter();
-        assert_eq!(1, iter.next().unwrap().extract().unwrap());
-        assert_eq!(2, iter.next().unwrap().extract().unwrap());
-        assert_eq!(3, iter.next().unwrap().extract().unwrap());
+        assert_eq!(1, iter.next().unwrap().extract::<i32>().unwrap());
+        assert_eq!(2, iter.next().unwrap().extract::<i32>().unwrap());
+        assert_eq!(3, iter.next().unwrap().extract::<i32>().unwrap());
     }
 
     #[test]
@@ -295,7 +295,7 @@ mod test {
         assert_eq!(3, tuple.len());
 
         for (i, item) in tuple.iter().enumerate() {
-            assert_eq!(i + 1, item.extract().unwrap());
+            assert_eq!(i + 1, item.extract::<usize>().unwrap());
         }
     }
 
@@ -309,8 +309,8 @@ mod test {
 
         let slice = tuple.as_slice();
         assert_eq!(3, slice.len());
-        assert_eq!(1, slice[0].extract().unwrap());
-        assert_eq!(2, slice[1].extract().unwrap());
-        assert_eq!(3, slice[2].extract().unwrap());
+        assert_eq!(1, slice[0].extract::<i32>().unwrap());
+        assert_eq!(2, slice[1].extract::<i32>().unwrap());
+        assert_eq!(3, slice[2].extract::<i32>().unwrap());
     }
 }
-- 
2.29.2

